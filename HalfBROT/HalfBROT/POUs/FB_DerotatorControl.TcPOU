<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.8">
  <POU Name="FB_DerotatorControl" Id="{acfc3cc1-a4bd-4873-ba58-50b0c54d8bf5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_DerotatorControl
VAR_INPUT
	enable			: BOOL;		// enable the derotator
	reset			: BOOL;		// reset an error
	position		: LREAL;	// set the absolute position
	velocity		: LREAL := 10.0;	// derotator velocity
	moveAxis		: BOOL;		// move to given position
	homeAxis		: BOOL;		// calibrate the axis
	tracking		: BOOL;		// tracking flag
	stopAxis		: BOOL;		// stop the Axis
	bSoEReset		: BOOL;		// diagnostic error code reset
	calibPosition	: LREAL := 438.4623; // calibration in positive direction (was 460.0)
	minPosition		: LREAL;
	maxPosition		: LREAL;
END_VAR
VAR_OUTPUT
	error			: BOOL;		// error flag
	errorID			: UDINT;	// nc error id
	actualPosition	: LREAL;	// actual position of the derotator
	calibrated		: BOOL;		// calibrated flag
	ready			: BOOL;		// axis ready flag
	slewTime		: LREAL;	// position to move the axis to
END_VAR
VAR
	comm			: I_Comm;	
	torqueError		: TON := (PT := T#3S);	// trigger for the torque error
	axis			: FB_Axis2;	// axis function block
	axisEvent		: FB_EventLog;
	torqueWarning	: FB_EventLog;	// torque warning event
	calibrationEvent: FB_EventLog;	// torque calibration event
	diagnosticEvent	: FB_EventLog;	// diagnostic low-level event
	torque			: REAL;	// percentage of the derotator torque
	readParameter	: MC_ReadParameter;	// read slewtime
	fbSoEReset		: FB_SoEReset;
	diagnosticError	: BOOL;
	left			: BOOL;		// decrease derotator angle
	right			: BOOL;		// increase derotator angle
	
	inDigitalInputs	AT%I*	: WORD;		// digitale inputs der Endlagen
	inDiagnostic	AT%I*	: UDINT;	// diagnostic number
	inTorque		AT%I*	: INT;		// derotator torque feedback
	inSTO			AT%I*	: BOOL;		// STO
	axisRef			: AXIS_REF;	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
Selection 6
Homing in Endlage:

https://infosys.beckhoff.com/index.php?content=../content/1031/ax5000_usermanual/html/ax5000_homing_hardware_end_position.htm&id=12221
NC-Interface:
PlcToNc-Achsinterface, Bit 8 namens AcceptBlockedDriveSignal im nDeCtrlDWord

SPS-Interface:
TcNc-Lib, siehe SPS-Funktion AxisSetAcceptBlockedDriveSignal in der TwinCAT  PLC Library: NC.
*)

position := LIMIT(minPosition, position, maxPosition);

IF enable AND NOT axis.Calibrated THEN
	homeAxis := TRUE;
END_IF

IF axis.Calibrated THEN
	homeAxis := FALSE;
	calibrated := axis.Calibrated;
END_IF
	
IF homeAxis THEN
	position := calibPosition;
END_IF

axis(
	enable 			:= enable,
	Reset 			:= reset,
	MoveAxis 		:= moveAxis,
	HomeAxis 		:= homeAxis,
	StopAxis 		:= stopAxis,
	HomingMode 		:= MC_ForceCalibration,
	Position 		:= position, 
	Velocity 		:= velocity,
	Enable_Positive := NOT inDigitalInputs.0,
	Enable_Negative := NOT inDigitalInputs.1,
	Jog_Forward 	:= right,
	Jog_Backwards 	:= left,
	bCalibrationCam := inDigitalInputs.0,
	isModuloAxis 	:= FALSE,
	Tracking 		:= tracking,
	ActualPosition 	=> actualPosition,
	Error 			=> error,
	ErrorID 		=> errorID,
	AxisRef 		:= axisRef);
	
IF axis.MoveDone OR reset OR error THEN
	moveAxis := FALSE;
END_IF

IF axis.HomeDone OR reset OR error THEN
	homeAxis := FALSE;
END_IF
	
IF axis.ResetDone THEN
	reset := FALSE;
END_IF

IF axis.StopDone THEN
	stopAxis := FALSE;
END_IF

diagnosticError := FALSE;
IF inDiagnostic < 16#D012 AND inDiagnostic > 16#D014 THEN
	diagnosticError := TRUE;
	errorID := inDiagnostic;
	bSoeReset := reset;
END_IF

ready := axis.Ready;

readParameter(	
	Axis 			:= axisRef, 
	Enable 			:= axis.InMotion, 
	ParameterNumber := MC_AxisParameter.AxisRemainingTimeToGo, 
	ReadMode 		:= E_ReadMode.READMODE_CYCLIC);
				
IF readParameter.Valid THEN
	slewtime := readParameter.Value;
END_IF

IF bSoEReset THEN
	fbSoEReset(
		Axis 	:= axisRef,
		Execute := TRUE,
		Timeout := DEFAULT_ADS_TIMEOUT);
 	IF NOT fbSoEReset.Busy THEN
		fbSoEReset(Axis := axisRef, Execute := FALSE);
		bSoEReset := FALSE;
		reset := TRUE;
	END_IF
END_IF

torque := inTorque / 10.0;
// nominal torque is 3%, max is 25%
torqueError(IN := ABS(torque) > 20.0);

axisEvent(	
	Trigger 		:= Error, 
	Level 			:= ADSLOG_MSGTYPE_ERROR,
	FormatString	:= 'Derotator Axis Error: %s',
	OnMessage 		:= NCError_TO_STRING(ErrorID),
	OffMEssage 		:= 'OK',
	OffLevel 		:= ADSLOG_MSGTYPE_HINT,
	Comm			:= comm);
	
diagnosticEvent(	
	Trigger 		:= DiagnosticError, 
	Level 			:= ADSLOG_MSGTYPE_ERROR,
	FormatString	:= 'Derotator Axis Diagnostic Error: %s',
	OnMessage 		:= NCError_TO_STRING(inDiagnostic),
	Comm			:= comm);
	
TorqueWarning(	
	Trigger 		:= TorqueError.Q, 
	Level 			:= ADSLOG_MSGTYPE_WARN,
	FormatString 	:= '%s',
	OnMessage 		:= 'Derotator torque is high.',
	Comm			:= comm);

CalibrationEvent(	
	Trigger 		:= Calibrated, 
	Level 			:= ADSLOG_MSGTYPE_HINT,
	OnMessage 		:= 'Derotator is calibrated.',
	Comm			:= comm);
	]]></ST>
    </Implementation>
    <Method Name="FB_Init" Id="{17d81d64-5647-49eb-8f39-4de9c4a6dd83}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains	: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode		: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
	comm			: I_Comm;   
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.comm := comm;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsInMaxLimit" Id="{85224394-9a32-4685-b3cf-6a13bc098736}">
      <Declaration><![CDATA[METHOD PUBLIC IsInMaxLimit : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IsInMaxLimit := inDigitalInputs.0;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsInMinLimit" Id="{62606f0a-fd18-40f4-8386-8e94886290d7}">
      <Declaration><![CDATA[METHOD PUBLIC IsInMinLimit : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IsInMinLimit := inDigitalInputs.1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsReady" Id="{8cc15e49-347f-420a-b869-3556a24cdf75}">
      <Declaration><![CDATA[METHOD PUBLIC IsReady : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IsReady := ready;]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveLeft" Id="{f9da8fce-1e75-499f-9e0c-b87953d543dc}">
      <Declaration><![CDATA[METHOD PUBLIC MoveLeft : BOOL
VAR_INPUT
	enable	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[left := enable;]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveRight" Id="{36c00668-a0dc-4b1f-8735-c26e99bf4c2c}">
      <Declaration><![CDATA[METHOD PUBLIC MoveRight : BOOL
VAR_INPUT
	enable	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[right := enable;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_DerotatorControl">
      <LineId Id="1263" Count="73" />
      <LineId Id="1389" Count="0" />
      <LineId Id="1337" Count="51" />
      <LineId Id="127" Count="0" />
    </LineIds>
    <LineIds Name="FB_DerotatorControl.FB_Init">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_DerotatorControl.IsInMaxLimit">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_DerotatorControl.IsInMinLimit">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_DerotatorControl.IsReady">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_DerotatorControl.MoveLeft">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_DerotatorControl.MoveRight">
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.8">
  <POU Name="FB_AzimuthControl" Id="{fd112fcf-fe5a-48e7-aea8-3fe8a57db212}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_AzimuthControl
VAR_INPUT
	enable					: BOOL;		// enable the axis and its position control loop
	reset					: BOOL;		// reset the axis
	left					: BOOL;		// decrease azimuth
	right					: BOOL;		// increase azimuth
	moveAxis				: BOOL;		// Move azimuth to given position
	homeAxis				: BOOL;		// Home the axis
	tracking				: BOOL;		// enable tracking
	position				: LREAL;	// position to move the axis to
	velocity				: LREAL;	// set the Velocity of the axis
	stopAxis				: BOOL;		// stop the Axis
	bSoEReset				: BOOL;		// diagnostic reset
	brakeOpen				: BOOL;		// azimuth break is open
	minPosition				: REAL := 0;
	maxPosition				: REAL := 450.0;
	calibPosition			: LREAL := 45.0; // // current position of the calibration cam
END_VAR
VAR_OUTPUT
	error					: BOOL;		// error state of the axis
	errorID					: UDINT;	// error ID of the axis
	actualPosition			: LREAL;	// actual_position of the axis
	calibrated				: BOOL;		// is the axis calibrated
	ready					: BOOL;		// drive is ready
	slewTime				: LREAL;	// time to reach target position
END_VAR
VAR
	comm					: I_Comm;	
	
	inDigitalInputs	  AT%I*	: WORD;		// digitale inputs der Endlagen
	inDiagnostic	  AT%I*	: UDINT;	// diagnostic number
	inTorque	 	  AT%I*	: INT;		// derotator torque feedback
	inSTO		  	  AT%I*	: BOOL;		// STO
	axisRef					: AXIS_REF;	
	
	axis				: FB_Axis2;
	axisCalibration		: MC_SetPosition;
	//fbSoEReset			  :	FB_SoEReset;
	axisEvent			: FB_EventLog;
	diagnosticEvent		: FB_EventLog;
	readyDelay			: TON;		// delay until commutator angle is measured
	homeDelay			: FB_TONTP;
	torqueError			: TON := (PT := T#3S);
	torque				: REAL;
	torqueWarning		: FB_EventLog;
	calibrationEvent	: FB_Eventlog;
	readParameter		: MC_ReadParameter;
	getLastPosition		: BOOL := TRUE;
	restTimer			: TON;
	atRest				: BOOL;
	fbSoEReset			: FB_SoEReset;
	diagnosticError		: BOOL;
END_VAR
VAR PERSISTENT
	lastPosition			: LREAL := -1.0;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* Azimuth Axis control section
Power must be on and brake must be open for the axis to operate
*)

// generate the ready signal after enabling the drive
readyDelay(IN :=  axis.Enable, PT := T#3000MS, Q=> ready);

// limit the input position angle
position := LIMIT(minPosition, position, maxPosition);

// conduct the calibrated signal
calibrated := axis.Calibrated;

IF calibrated OR error THEN
	homeAxis := FALSE;
	getlastposition := FALSE;
END_IF
	
IF homeAxis THEN
	position := calibPosition;
END_IF

IF homeDelay.Q THEN
	position := calibPosition;
	moveAxis := TRUE;
END_IF

// perform a recalibration on the last known position
axisCalibration(
	Axis 		:= axisRef,
	Execute 	:= getlastposition AND lastPosition>=0.0 AND NOT calibrated,
	Position 	:= lastPosition);

IF axisCalibration.Done THEN
	getLastPosition := FALSE;
END_IF

IF calibrated THEN
	lastPosition := actualPosition;
END_IF

// enable the azimuth if not moved by the power chain. Sorry for the hack
restTimer(IN := brakeOpen AND (ABS(axisRef.NcToPlc.ActVelo) < 0.01), PT := T#2S);
// if azimuth at rest or calibrated, allow enabling the azimuth
IF restTimer.Q or calibrated THEN
	atRest := TRUE;
ELSIF NOT brakeOpen THEN
	atRest := FALSE;
END_IF
	
// deactivate limit switches on homing
MC_SetAcceptBlockedDriveSignal(
	Axis 	:= axisRef, 
	Enable 	:= HomeAxis);

axis(	
	Enable 			:= enable AND atRest,
	Reset 			:= reset,
	MoveAxis 		:= moveAxis,
	HomeAxis 		:= homeAxis,
	StopAxis 		:= stopAxis,
	Tracking 		:= tracking,
	Position 		:= position, 
	Velocity 		:= velocity,
	Enable_Positive := inDigitalInputs.1 OR HomeAxis,
	Enable_Negative := inDigitalInputs.0,
	Jog_Forward 	:= right,
	Jog_Backwards 	:= left,
	bCalibrationCam := NOT inDigitalInputs.1,
	ActualPosition 	=> actualPosition,
	Error 			=> error,
	ErrorID 		=> errorID,
	AxisRef 		:= axisRef);

IF bSoEReset THEN
	lastPosition := -1.0;
	fbSoEReset(
		Axis 	:= axisRef,
		Execute := TRUE,
		Timeout := DEFAULT_ADS_TIMEOUT);
 	IF fbSoEReset.Busy THEN
		fbSoEReset(Axis := axisRef, Execute := FALSE);
	ELSE
		bSoEReset := FALSE;
		Reset := TRUE;
	END_IF
END_IF 

IF axis.MoveDone THEN
	moveAxis := FALSE;
END_IF

IF axis.HomeDone THEN
	homeAxis := FALSE;
END_IF
	
IF axis.ResetDone THEN
	reset := FALSE;
END_IF

IF axis.StopDone THEN
	stopAxis := FALSE;
END_IF
diagnosticError := FALSE;
IF inDiagnostic < 16#D012 AND inDiagnostic > 16#D014 THEN
	diagnosticError :=TRUE;
	errorID := inDiagnostic;
END_IF

readParameter(	
	Axis 			:= axisRef, 
	Enable 			:= axis.InMotion, 
	ParameterNumber := MC_AxisParameter.AxisRemainingTimeToGo, 
	ReadMode 		:= E_ReadMode.READMODE_CYCLIC);
IF readParameter.Valid THEN
	slewTime := readParameter.Value;
END_IF

torque := inTorque / 10.0;
torqueError(IN := ABS(torque) > 50.0);

axisEvent(	
	Trigger 		:= error, 
	Level 			:= ADSLOG_MSGTYPE_ERROR,
	FormatString 	:= 'Azimuth Axis Error: %s',
	OnMessage 		:= NCError_TO_STRING(ErrorID),
	Comm 			:= comm);
	
diagnosticEvent(	
	Trigger 		:= diagnosticError,
	Level 			:= ADSLOG_MSGTYPE_ERROR,
	FormatString 	:= 'Azimuth Axis Diagnostic Error: %s',
	OnMessage 		:= NCError_TO_STRING(inDiagnostic),
	Comm 			:= comm);
	
TorqueWarning(	
	Trigger 		:= torqueError.Q, 
	Level 			:= ADSLOG_MSGTYPE_WARN,
	FormatString 	:= '%s',
	OnMessage 		:= 'Azimuth torque is high.',
	Comm 			:= comm);
	
CalibrationEvent(
	Trigger 		:= calibrated, 
	Level 			:= ADSLOG_MSGTYPE_HINT,
	FormatString 	:= '%s',
	OnMessage 		:= 'Azimuth axis is calibrated.',
	Comm 			:= comm);
				]]></ST>
    </Implementation>
    <Method Name="FB_Init" Id="{da5bbb3a-7afb-4e44-92f3-c2b7880a01c6}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains	: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode		: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
	comm			: I_Comm;	   
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.comm := comm;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_AzimuthControl">
      <LineId Id="2374" Count="147" />
      <LineId Id="149" Count="0" />
    </LineIds>
    <LineIds Name="FB_AzimuthControl.FB_Init">
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.8">
  <POU Name="FB_PendantControl" Id="{e2b10f6c-d16d-4403-9ebe-8d8a369c8dbd}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PendantControl
VAR_INPUT
END_VAR
VAR
	CoverControl		: REFERENCE TO FB_CoverControl;
	HydraulicsControl	: REFERENCE TO FB_HydraulicsControl;
	Focuscontrol 		: REFERENCE TO FB_Focuscontrol;
	ElevationControl	: REFERENCE TO FB_ElevationControl;
	AzimuthControl 		: REFERENCE TO FB_AzimuthControl;
	DerotatorControl	: REFERENCE TO FB_DerotatorControl;
	TelescopeControl	: REFERENCE TO FB_TelescopeControl;
	comm				: I_Comm;

	// program selection of the pendant control
	Selection:	UINT;
	// error on the pendant control
	Error:		BOOL;
	horn:			BOOL;
	FocusEnable: 		FB_ButtonEnable;
	DerotatorEnable:	FB_ButtonEnable;
	ElevationEnable: 	FB_ButtonEnable;
	AzimuthEnable: 		FB_ButtonEnable;
	TelescopeControlEnable: 	FB_ButtonEnable;
	HydraulicsEnable: 	FB_ButtonEnable;
	TrackingEnable:			FB_ButtonEnable;
	ResetDelay:	TON;
	TwinCATRestart: TC_Restart;
	up_trigger:	R_TRIG;
	down_trigger:	R_TRIG;	
	// manual or automatic operation of the telescope
	telescope_mode : E_TelescopeMode;

	//DIN17 2.0
	BCD0		AT%I*: BOOL;
	//DIN18 2.1
	BCD2		AT%I*: BOOL;
	//DIN19 2.2
	BCD4		AT%I*: BOOL;
	//DIN20 2.3
	BCD8		AT%I*: BOOL;
	//DIN21 2.4
	reset_switch	AT%I*: BOOL;
	//DIN22 2.5
	direction_up	AT%I*: BOOL;
	//DIN23 2.6
	direction_down	AT%I*: BOOL;
	//DIN24 2.7
	key_switch		AT%I*: BOOL;
	//DIN25 3.0 (enable)
	start_switch	AT%I*: BOOL;
	//DIN26 3.1
	direction_left	AT%I*: BOOL;
	//DIN27 3.2
	direction_right	AT%I*: BOOL;
	
	// Outputs
	
	//DOUT9 1.0
	lamp_up			AT%Q*: BOOL;
	//DOUT10 1.1
	lamp_down			AT%Q*: BOOL;
	//DOUT11 1.2
	lamp_right			AT%Q*: BOOL;
	//DOUT12 1.3
	lamp_left			AT%Q*: BOOL;
	//DOUT13 1.4
	lamp_error			AT%Q*: BOOL;	
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* 
This program is responsible for the manual control of the telescope.
all movable parts can be controlled from here. This is mainly for testing and
maintenance.
WARNING! Some of the safety routines are disabled, when operating the telescope manually.
*)
// calculate the value of the selector
Selection := 1*BOOL_TO_UINT(BCD0) + 
			 2*BOOL_TO_UINT(BCD2) + 
			 4*BOOL_TO_UINT(BCD4) +
			 8*BOOL_TO_UINT(BCD8);

// detect disconnection of the manual controls (should also trigger emergency stop).			 
Error := (Selection = 0);

// disable all the lamps
lamp_left := FALSE;
lamp_right := FALSE;
lamp_up := FALSE;
lamp_down := FALSE;
horn := FALSE;

up_trigger(CLK := direction_up);
down_trigger(CLK := direction_down);
//R_Enable(CLK := enable);
// the error lamp is the same as the error lamp of the main panel
lamp_error := lamp_error;


// determine the operation of the telescope based on the switch set
IF key_switch THEN
	telescope_mode := E_TelescopeMode.manual;
ELSE
	telescope_mode := E_TelescopeMode.automatic;
END_IF

// enable only the selected item and connect lamps and buttons accordingly
CASE Selection OF
	1:	// reserved for Cover1 control
		lamp_up := CoverControl.cover1Open;
		lamp_down := CoverControl.cover1Closed;
		IF key_switch THEN
			//CoverEnable(SET := enable, Q := CoverControl.enable);
			//CoverControl.active_cover := 1;
			//CoverControl.reset := reset;
			CoverControl.outOpenCover1 := direction_up AND CoverControl.cover1Open;
			CoverControl.outCloseCover1 := direction_down AND CoverControl.cover1Closed;
			lamp_error := CoverControl.cover1Error;	
		ELSE
			IF direction_down THEN 
				CoverControl.close := TRUE;
			END_IF
			IF direction_up THEN
				CoverControl.open := TRUE;
			END_IF		
		END_IF

	2: // Cover2 control
		lamp_up := CoverControl.cover2Open;
		lamp_down := CoverControl.cover2Closed;
		IF key_switch THEN
			//CoverEnable(SET := enable, Q := CoverControl.enable);
			//CoverControl.active_cover := 2;
			CoverControl.outOpenCover2 := direction_up AND CoverControl.cover2Open;
			CoverControl.outCloseCover2 := direction_down AND CoverControl.cover2Closed;
			lamp_error := CoverControl.cover2Error;
		ELSE
			IF direction_down THEN 
				CoverControl.close := TRUE;
			END_IF
			IF direction_up THEN
				CoverControl.open := TRUE;
			END_IF		
		END_IF
 	
	3:  // Cover3 control
		lamp_up := CoverControl.cover3Open;
		lamp_down := CoverControl.cover3Closed;
		IF key_switch THEN
			//CoverEnable(SET := enable, Q := CoverControl.enable);
			//CoverControl.active_cover := 3;
			CoverControl.outOpenCover3 := direction_up AND CoverControl.cover3Open;
			CoverControl.outCloseCover3 := direction_down AND CoverControl.cover3Closed;
			//CoverControl.reset := reset;
			lamp_error := CoverControl.cover3Error;
		ELSE
			IF direction_down THEN 
				CoverControl.close := TRUE;
			END_IF
			IF direction_up THEN
				CoverControl.open := TRUE;
			END_IF		
		END_IF
		
	4:	// Nasmyth / mirror M3 control
		
	5:	// Focus Control
		lamp_up := FocusControl.Ready AND NOT FocusControl.limitFar;
		lamp_down := FocusControl.Ready AND NOT FocusControl.limitNear;
		IF key_switch THEN
			FocusEnable(SET := start_switch, Q := FocusControl.enable);
			FocusControl.MoveOut(direction_up);
			FocusControl.MoveIn(direction_down);
			Focuscontrol.reset := reset_switch;
			lamp_error := FocusControl.error;
		END_IF
							
	6:	// Derotator control
		lamp_left  := DerotatorControl.IsReady() AND NOT DerotatorControl.IsInMinLimit();
		lamp_right := DerotatorControl.IsReady() AND NOT DerotatorControl.IsInMaxLimit();
		IF key_switch THEN
			DerotatorEnable(SET := start_switch, Q := DerotatorControl.enable);
			DerotatorControl.MoveLeft(direction_left AND NOT DerotatorControl.inDigitalInputs.1);
			DerotatorControl.MoveRight(direction_right AND NOT DerotatorControl.inDigitalInputs.0);
			DerotatorControl.reset := reset_switch;
			lamp_error := DerotatorControl.Error;
		END_IF
							
	7:	// Elevation Control
		
		ElevationControl.up := direction_up AND ElevationControl.inDigitalInputs.0;
		ElevationControl.down := direction_down AND ElevationControl.inDigitalInputs.1;
		IF key_switch THEN
			ElevationEnable(
				SET := start_switch, 
				Q := ElevationControl.enable);	
		END_IF
		ElevationControl.reset := reset_switch;
		lamp_up := ElevationControl.inDigitalInputs.0;
		lamp_down := ElevationControl.inDigitalInputs.1;
		lamp_error := ElevationControl.error;
		
	8:	// Azimuth Control
		lamp_left := AzimuthControl.inDigitalInputs.0; // NOT GVL_Telescope.azimut_limit_switch;
		lamp_right := AzimuthControl.inDigitalInputs.1; // NOT GVL_Telescope.azimut_limit_switch;
		AzimuthControl.left := direction_left AND AzimuthControl.inDigitalInputs.0;
		AzimuthControl.right := direction_right AND AzimuthControl.inDigitalInputs.1;
		AzimuthControl.reset := reset_switch;
		IF key_switch THEN
			AzimuthEnable(
				SET := start_switch, 
				Q := AzimuthControl.enable);
			lamp_error := AzimuthControl.error;
		END_IF
		
	9: 	// Dome control
		
	10:	// FilterWheel control
		
	11: lamp_up := ElevationControl.torque > 0.0;
		lamp_down := ElevationControl.torque < 0.0;
		
	12:	// manual Telescope Control
		IF key_switch THEN
			lamp_up := TelescopeControl.power;
			lamp_down := TelescopeControl.power;
			lamp_left := TelescopeControl.power;
			lamp_right := TelescopeControl.power;
	
			TelescopeControl.gohome := direction_down;
			TelescopeControl.park := direction_up;
			TelescopeControl.goto := direction_right;
			TrackingEnable(SET := start_switch, 
							RESET := reset_switch, 
							Q := TelescopeControl.track);
			TelescopeControl.reset := reset_switch;
			Telescopecontrol.stop := direction_left;	
			lamp_error := Telescopecontrol.error;
		END_IF
		
	13: // Telescope Control
		TelescopeControlEnable(
			SET := start_switch, 
			Q := TelescopeControl.power);
		TelescopeControl.reset := reset_switch;
		IF key_switch THEN
			lamp_up := ElevationControl.inDigitalInputs.0;
			lamp_down := ElevationControl.inDigitalInputs.1;
			lamp_left := AzimuthControl.inDigitalInputs.0;
			lamp_right := AzimuthControl.inDigitalInputs.1;
			ElevationControl.up := direction_up AND ElevationControl.inDigitalInputs.0;
			ElevationControl.down := direction_down AND ElevationControl.inDigitalInputs.1;
			AzimuthControl.left := direction_left AND AzimuthControl.inDigitalInputs.0;
			AzimuthControl.right := direction_right AND AzimuthControl.inDigitalInputs.1;
			TelescopeControl.rightascension := TelescopeControl.rightascension_calc;
			TelescopeControl.declination := TelescopeControl.declination_calc;
		ELSE
			lamp_up := ElevationControl.enable;
			lamp_down := ElevationControl.enable;
			lamp_left := AzimuthControl.enable;
			lamp_right := AzimuthControl.enable;
			IF direction_up THEN 
				Telescopecontrol.elevation_offset := Telescopecontrol.elevation_offset + 10.0/3600.0; 
			ELSIF direction_down THEN 
				Telescopecontrol.elevation_offset := Telescopecontrol.elevation_offset - 10.0/3600.0; 
			END_IF;
			IF direction_left THEN 
				Telescopecontrol.azimuth_offset := Telescopecontrol.azimuth_offset - 10.0/3600.0; 
			ELSIF direction_right THEN 
				Telescopecontrol.azimuth_offset := Telescopecontrol.azimuth_offset + 10.0/3600.0; 
			END_IF;
		END_IF
		ResetDelay(IN := reset_switch, PT := T#3S);
		// wait for suction pump to stop
		TwinCATRestart(NETID := '', RESTART := ResetDelay.Q AND NOT HydraulicsControl.suctionRunning, TMOUT := T#60S);
	
	14: horn := key_switch;
		lamp_up := key_switch;
		lamp_down := key_switch;
		lamp_left := key_switch;
		lamp_right := key_switch;
	
	15:	// Hydraulics control
		lamp_up := HydraulicsControl.oilPressureOK AND Hydraulicscontrol.brakeClosed;
		lamp_down := HydraulicsControl.oilPressureOK AND Hydraulicscontrol.brakeOpen;
		lamp_left := HydraulicsControl.pumpRunning;
		lamp_right := HydraulicsControl.suctionRunning;
		IF key_switch THEN
			HydraulicsEnable(
				SET := start_switch, 
				Q := Hydraulicscontrol.enable);
			Hydraulicscontrol.reset := reset_switch;
			
			IF direction_up THEN
				Hydraulicscontrol.open_brake();
			END_IF
			IF direction_down THEN
				Hydraulicscontrol.close_brake();
			END_IF
			HydraulicsControl.suctionManual := direction_right;
			HydraulicsControl.pumpManualStop := direction_left;
			lamp_error := HydraulicsControl.error;
		END_IF
END_CASE
]]></ST>
    </Implementation>
    <Method Name="FB_Init" Id="{377c4b19-44fb-4929-801b-86205f66218e}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
	cover			: REFERENCE TO FB_CoverControl;
	hydraulics 		: REFERENCE TO FB_HydraulicsControl;
	focus			: REFERENCE TO FB_FocusControl;
	elevation		: REFERENCE TO FB_ElevationControl;
	azimuth			: REFERENCE TO FB_AzimuthControl;
	derotator		: REFERENCE TO FB_DerotatorControl;
	telescope		: REFERENCE TO FB_TelescopeControl;
	comm			: I_Comm;   
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.HydraulicsControl REF= hydraulics;
THIS^.CoverControl REF= cover;
THIS^.FocusControl REF= focus;
THIS^.ElevationControl REF= elevation;
THIS^.AzimuthControl REF= azimuth;
THIS^.DerotatorControl REF= derotator;
THIS^.TelescopeControl REF= telescope;
THIS^.comm := comm;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_PendantControl">
      <LineId Id="1" Count="234" />
    </LineIds>
    <LineIds Name="FB_PendantControl.FB_Init">
      <LineId Id="1" Count="5" />
      <LineId Id="8" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
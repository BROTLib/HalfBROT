<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.8">
  <POU Name="FB_CoverControl" Id="{febe04fb-b0fe-4b52-a725-1c7655537933}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_CoverControl IMPLEMENTS I_MirrorCover
VAR_INPUT
	reset					: BOOL;		// resets all drives after an error has occured
	open					: BOOL;		// open the cover in proper order
	close					: BOOL;		// close the cover in proper order
	
	outOpenCover1	AT%Q*	: BOOL;	// open cover1 command
	outCloseCover1	AT%Q*	: BOOL; // close cover1 command
	outOpenCover2	AT%Q*	: BOOL; // open cover2 command
	outCloseCover2	AT%Q*	: BOOL; // close cover2 command
	outOpenCover3	AT%Q*	: BOOL; // open cover3 command
	outCloseCover3	AT%Q*	: BOOL; // close cover3 command
END_VAR
VAR_OUTPUT
	is_open				: BOOL;		// all covers are open
	is_closed			: BOOL;		// all covers are closed
	error				: BOOL;		// any cover-driver reports an error
	warning				: BOOL;		// warning state of the DC drives
END_VAR
VAR
	comm				: I_Comm;	
	active_cover		: INT;		// actual active cover in manual mode, 0 for automatic = all covers active
	
	// limit switches
	inCover1Open	AT%I*	: BOOL;	// limit coper 1 open
	inCover1Closed	AT%I*	: BOOL;	// limit coper 1 closed
	inCover2Open	AT%I*	: BOOL; // limit coper 2 open
	inCoverClosed	AT%I*	: BOOL;	///limit coper 2 closed
	inCover3Open	AT%I*	: BOOL;	// limit coper 3 open
	inCover3Closed	AT%I*	: BOOL;	// limit coper 3 closed	
	
	cover1Open	  			: BOOL;	// cover1 is open 
	cover1Closed			: BOOL; // cover1 is closed
	cover1Error				: BOOL; // cover1 has error
	
	cover2Open				: BOOL; // cover2 is open
	cover2Closed			: BOOL; // cover2 is closed
	cover2Error				: BOOL; // cover2 has error

	cover3Open				: BOOL; // cover3 is open
	cover3Closed			: BOOL; // cover3 is closed
	cover3Error				: BOOL; // cover3 has error	
	
	cover2ODelay			: TON := (PT:=T#1S);	// delay timer for opening cover2
	cover3CloseDelay 		: TON := (PT:=T#3S);	// dely timer for closing cover3

	errorTrigger			: SR;	// trigger for error
	
	cover1Event				: FB_EventLog;	// error event for cover1
	cover2Event				: FB_EventLog;	// error event for cover2
	cover3Event				: FB_EventLog;	// error event for cover3

	cover1TimeoutEvent		: FB_EventLog; // timeout event for cover1
	cover2TimeoutEvent		: FB_EventLog; // timeout event for cover2
	cover3TimeoutEvent		: FB_EventLog; // timeout event for cover3
	
	coversOpenedEvent		: FB_EventLog; // log if covers are open
	coversClosedEvent		: FB_EventLog; // log if covers are closed
	coversErrorEvent		: FB_EventLog; // Event log for a generic drive error
	coversWarningEvent		: FB_EventLog; // Event log for a generic drive warning
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
This is the control for the two (three) telescope covers. 
The correct order for opening is 1->3->2 and for closing 2->3->1.
GVL Open and close signals are inverted
*)

// close has precedence over open
IF close THEN
	open := FALSE;
END_IF

// limit switches are inverted
cover1Open   := NOT inCover1Open;
cover2Open   := NOT inCover2Open;
cover3Open   := NOT inCover3Open;
cover1Closed := NOT inCover1Closed;
cover2Closed := NOT inCoverClosed;
cover3Closed := NOT inCover3Closed;

// errors occur if covers are both opened and closed
cover1Error := cover1Open AND cover1Closed;
cover2Error := cover2Open AND cover2Closed;
cover3Error := cover3Open AND cover3Closed;

// wait for cover2 until cover3 has left the closed state
cover2ODelay(IN := open AND NOT cover3Closed);
// wait for cover3 until cover2 has left the open state
cover3CloseDelay(IN := close AND NOT cover2Open);

// commands
IF close THEN
	outCloseCover1 := inCover1Closed AND NOT inCover3Closed;
	outCloseCover2 := inCoverClosed;
	outCloseCover3 := inCover3Closed AND cover3CloseDelay.Q;
ELSIF open THEN
	outOpenCover1 := inCover1Open;
	outOpenCover2 := inCover2Open AND cover2ODelay.Q;
	outOpenCover3 := inCover3Open;			
END_IF

// we are open, if all covers are open
is_open := cover3Open AND cover2Open AND cover1Open;
// we are closed, if all covers are closed
is_closed := cover2Closed AND cover3Closed AND cover1Closed;

// error indicates an axis error on any axis
errorTrigger(
	SET1 := cover1Error OR cover2Error OR cover3Error,
	RESET := reset,
	Q1 => error);

IF is_closed THEN
	close := FALSE;
END_IF

IF is_open THEN
	open := FALSE;
END_IF

coversErrorEvent.OnMessage := 'Cover drive error';
IF Error THEN
	IF cover3Error THEN 
		coversErrorEvent.OnMessage := 'Cover 3 has a drive error.';
	END_IF
	IF cover2Error THEN 
		coversErrorEvent.OnMessage := 'Cover 2 has a drive error.';
	END_IF
	IF cover1Error THEN 
		coversErrorEvent.OnMessage := 'Cover 1 has a drive error.';
	END_IF
END_IF

coversErrorEvent(
	Trigger 	:= error, 
   	Level   	:= ADSLOG_MSGTYPE_ERROR, 
	comm 		:= comm);

coversWarningEvent(
	Trigger 	:= warning, 
	Level   	:= ADSLOG_MSGTYPE_WARN, 
	comm 		:= comm);

// raise an error, if both opened and closed signals are activated
// handle RoboTel differently
cover1Event(
	Trigger   	:= cover1Open AND cover1Closed,
	Level     	:= ADSLOG_MSGTYPE_ERROR, 
	OnMessage 	:= 'Cover1: limit switch error', 
	comm	 	:= comm);

cover2Event(
	Trigger   	:= cover2Open AND cover2Closed,
    Level     	:= ADSLOG_MSGTYPE_ERROR, 
	OnMessage 	:= 'Cover2: limit switch error', 
	comm      	:= comm);

cover3Event(
	Trigger   	:= cover3Open AND cover3Closed,
	Level     	:= ADSLOG_MSGTYPE_ERROR, 
	OnMessage 	:= 'Cover3: limit switch error', 
	comm 	  	:= comm);

//trigger an event, if we encounter a timeout
// handle RoboTel differently
cover1TimeoutEvent(
	Trigger   	:= FALSE,
	Level     	:= ADSLOG_MSGTYPE_ERROR, 
	OnMessage 	:= 'Cover1: Timeout',
	comm 		:= comm);
cover2TimeoutEvent(
	Trigger   	:= FALSE,
 	Level     	:= ADSLOG_MSGTYPE_ERROR, 
	OnMessage 	:= 'Cover2: Timeout',
	comm 		:= comm);
cover3TimeoutEvent(
	Trigger   	:= FALSE,
	Level     	:= ADSLOG_MSGTYPE_ERROR, 
	OnMessage 	:= 'Cover3: Timeout',
	comm 		:= comm);

// Log if we are opened
coversOpenedEvent(
	Trigger   	:= is_open,
	Level     	:= ADSLOG_MSGTYPE_WARN,
	OnMessage 	:= 'All covers are open',
	comm 		:= comm);
	
//log if we are closed
coversClosedEvent(
	Trigger   	:= is_closed,
	Level     	:= ADSLOG_MSGTYPE_HINT,
	OnMessage 	:= 'All covers are closed',
	comm 		:= comm);
]]></ST>
    </Implementation>
    <Method Name="CloseCover" Id="{da11c9a0-3757-4491-b03d-01cf2bd99294}">
      <Declaration><![CDATA[METHOD CloseCover : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[open := FALSE;
close := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_Init" Id="{f7653641-ffea-4063-9b54-57e57f75d284}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains	: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode		: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
	comm			: I_Comm;   
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.comm := comm;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsOpen" Id="{c4b9cdc7-29a2-4bcd-8657-0ea5ad75864e}">
      <Declaration><![CDATA[METHOD IsOpen : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IsOpen := is_open;]]></ST>
      </Implementation>
    </Method>
    <Method Name="OpenCover" Id="{bb6e1357-2f21-45f8-bb34-0ba057923977}">
      <Declaration><![CDATA[METHOD OpenCover : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[open := TRUE;
close := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetCover" Id="{3fcca07c-1b9c-4f16-918b-5d284513a3d3}">
      <Declaration><![CDATA[METHOD ResetCover : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ResetCover := TRUE;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_CoverControl">
      <LineId Id="2690" Count="132" />
      <LineId Id="122" Count="0" />
    </LineIds>
    <LineIds Name="FB_CoverControl.CloseCover">
      <LineId Id="1" Count="1" />
    </LineIds>
    <LineIds Name="FB_CoverControl.FB_Init">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_CoverControl.IsOpen">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_CoverControl.OpenCover">
      <LineId Id="1" Count="1" />
    </LineIds>
    <LineIds Name="FB_CoverControl.ResetCover">
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
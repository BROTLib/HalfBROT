<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.8">
  <POU Name="FB_CoverControl" Id="{febe04fb-b0fe-4b52-a725-1c7655537933}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_CoverControl IMPLEMENTS I_MirrorCover
VAR_INPUT
	reset					: BOOL;		// resets all drives after an error has occured
	open					: BOOL;		// open the cover in proper order
	close					: BOOL;		// close the cover in proper order
	comm					: I_Comm;
	
	open_cover1		AT%Q*	: BOOL;	// open cover1 command
	close_cover1	AT%Q*	: BOOL; // close cover1 command
	open_cover2		AT%Q*	: BOOL; // open cover2 command
	close_cover2	AT%Q*	: BOOL; // close cover2 command
	open_cover3		AT%Q*	: BOOL; // open cover3 command
	close_cover3	AT%Q*	: BOOL; // close cover3 command
END_VAR
VAR_OUTPUT
	isopen				: BOOL;		// all covers are open
	isclosed			: BOOL;		// all covers are closed
	error				: BOOL;		// any cover-driver reports an error
	warning				: BOOL;		// warning state of the DC drives
END_VAR
VAR
	active_cover		: INT;		// actual active cover in manual mode, 0 for automatic = all covers active
	
	// limit switches
	limit_cover1_open		AT%I*	: BOOL;
	// DIN34 4.1
	limit_cover1_closed		AT%I*	: BOOL;
	// DIN35 4.2
	limit_cover2_open		AT%I*	: BOOL;
	// DIN36 4.3
	limit_cover2_closed		AT%I*	: BOOL;
	// DIN37 4.4
	limit_cover3_open		AT%I*	: BOOL;
	// DIN38 4.5
	limit_cover3_closed		AT%I*	: BOOL;	
	
	cover1_open	  					: BOOL;	// cover1 is open 
	cover1_closed					: BOOL; // cover1 is closed
	cover1_error					: BOOL; // cover1 has error
	
	cover2_open						: BOOL; // cover2 is open
	cover2_closed					: BOOL; // cover2 is closed
	cover2_error					: BOOL; // cover2 has error

	cover3_open						: BOOL; // cover3 is open
	cover3_closed					: BOOL; // cover3 is closed
	cover3_error					: BOOL; // cover3 has error	
	
	// delay timer for opening cover2
	open2_delay						: TON := (PT:=T#1S);
	// dely timer for closing cover3
	close3_delay 					: TON := (PT:=T#3S);

	// trigger for error
	error_trigger					: SR;
	
	cover1_event					: FB_EventLog;	// error event for cover1
	cover2_event					: FB_EventLog;	// error event for cover2
	cover3_event					: FB_EventLog;	// error event for cover3

	
	cover1_timeout_event			: FB_EventLog; // timeout event for cover1
	cover2_timeout_event			: FB_EventLog; // timeout event for cover2
	cover3_timeout_event			: FB_EventLog; // timeout event for cover3
	
	covers_opened_event				: FB_EventLog; // log if covers are open
	covers_closed_event				: FB_EventLog; // log if covers are closed
	covers_error_event				: FB_EventLog; // Event log for a generic drive error
	covers_warning_event			: FB_EventLog; // Event log for a generic drive warning
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
This is the control for the two (three) telescope covers. 
The correct order for opening is 1->3->2 and for closing 2->3->1.
GVL Open and close signals are inverted
*)

// close has precedence over open
IF close THEN
	open := FALSE;
END_IF

// limit switches are inverted
cover1_open   := NOT limit_cover1_open;
cover2_open   := NOT limit_cover2_open;
cover3_open   := NOT limit_cover3_open;
cover1_closed := NOT limit_cover1_closed;
cover2_closed := NOT limit_cover2_closed;
cover3_closed := NOT limit_cover3_closed;

// errors occur if covers are both opened and closed
cover1_error := cover1_open AND cover1_closed;
cover2_error := cover2_open AND cover2_closed;
cover3_error := cover3_open AND cover3_closed;

// wait for cover2 until cover3 has left the closed state
open2_delay(IN := open AND NOT cover3_closed);
// wait for cover3 until cover2 has left the open state
close3_delay(IN := close AND NOT cover2_open);

// commands
IF close THEN
	close_cover1 := limit_cover1_closed AND NOT limit_cover3_closed;
	close_cover2 := limit_cover2_closed;
	close_cover3 := limit_cover3_closed AND close3_delay.Q;
ELSIF open THEN
	open_cover1 := limit_cover1_open;
	open_cover2 := limit_cover2_open AND open2_delay.Q;
	open_cover3 := limit_cover3_open;			
END_IF

// we are open, if all covers are open
isopen := cover3_open AND cover2_open AND cover1_open;
// we are closed, if all covers are closed
isclosed := cover2_closed AND cover3_closed AND cover1_closed;

// error indicates an axis error on any axis
error_trigger(SET1 := Cover1_error OR Cover2_error OR Cover3_error,
				RESET := reset,
				Q1 => error);

IF isclosed THEN
	close := FALSE;
END_IF

IF isopen THEN
	open := FALSE;
END_IF

covers_error_event.OnMessage := 'Cover drive error';
IF Error THEN
	IF cover3_error THEN 
		covers_error_event.OnMessage := 'Cover 3 has a drive error.';
	END_IF
	IF cover2_error THEN 
		covers_error_event.OnMessage := 'Cover 2 has a drive error.';
	END_IF
	IF cover1_error THEN 
		covers_error_event.OnMessage := 'Cover 1 has a drive error.';
	END_IF
END_IF

covers_error_event(Trigger := error, 
				   Level   := ADSLOG_MSGTYPE_ERROR);

covers_warning_event(Trigger := warning, 
					 Level   := ADSLOG_MSGTYPE_WARN);

// raise an error, if both opened and closed signals are activated
// handle RoboTel differently
cover1_event(Trigger   := cover1_open AND cover1_closed,
			 Level     := ADSLOG_MSGTYPE_ERROR, 
			 OnMessage := 'Cover1: limit switch error');

cover2_event(Trigger   := cover2_open AND cover2_closed,
			 Level     := ADSLOG_MSGTYPE_ERROR, 
			 OnMessage := 'Cover2: limit switch error');

cover3_event(Trigger   := cover3_open AND cover3_closed,
			 Level     := ADSLOG_MSGTYPE_ERROR, 
			 OnMessage := 'Cover3: limit switch error');

//trigger an event, if we encounter a timeout
// handle RoboTel differently

cover1_timeout_event(Trigger   := FALSE,
					 Level     := ADSLOG_MSGTYPE_ERROR, 
					 OnMessage := 'Cover1: Timeout');
cover2_timeout_event(Trigger   := FALSE,
					 Level     := ADSLOG_MSGTYPE_ERROR, 
					 OnMessage := 'Cover2: Timeout');
cover3_timeout_event(Trigger   := FALSE,
					 Level     := ADSLOG_MSGTYPE_ERROR, 
					 OnMessage := 'Cover3: Timeout');
					 
// Log if we are opened
covers_opened_event(Trigger   := isopen,
					Level     := ADSLOG_MSGTYPE_WARN,
					OnMessage := 'All covers are open');
//log if we are closed
covers_closed_event(Trigger   := isclosed,
					Level     := ADSLOG_MSGTYPE_HINT,
					OnMessage := 'All covers are closed');
]]></ST>
    </Implementation>
    <Method Name="CloseCover" Id="{da11c9a0-3757-4491-b03d-01cf2bd99294}">
      <Declaration><![CDATA[METHOD CloseCover : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[open := FALSE;
CloseCover := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="OpenCover" Id="{bb6e1357-2f21-45f8-bb34-0ba057923977}">
      <Declaration><![CDATA[METHOD OpenCover : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[OpenCover := TRUE;
close := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetCover" Id="{3fcca07c-1b9c-4f16-918b-5d284513a3d3}">
      <Declaration><![CDATA[METHOD ResetCover : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ResetCover := TRUE;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_CoverControl">
      <LineId Id="304" Count="96" />
      <LineId Id="402" Count="2" />
      <LineId Id="406" Count="2" />
      <LineId Id="417" Count="0" />
      <LineId Id="409" Count="7" />
      <LineId Id="115" Count="0" />
    </LineIds>
    <LineIds Name="FB_CoverControl.CloseCover">
      <LineId Id="6" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_CoverControl.OpenCover">
      <LineId Id="7" Count="0" />
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="FB_CoverControl.ResetCover">
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.8">
  <POU Name="FB_ElevationControl" Id="{163e8baa-c820-4d82-9b8f-2bab0c8d4398}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_ElevationControl
VAR_INPUT
	enable			: BOOL;		// enable the axis
	reset			: BOOL;		// reset an error
	up				: BOOL;		// increase the eleveation
	down			: BOOL;		// decrease the elevation
	position		: LREAL;	// set position of the axis in degrees
	velocity		: LREAL;	// set the Velocity of the axis
	moveAxis		: BOOL;		// move axis command
	homeAxis		: BOOL;		// calibrate the axis
	tracking		: BOOL;		// enable tracking
	stopAxis		: BOOL;		// stop the Axis
	bSoEReset		: BOOL;		// reset diagnostic errors
	calibPosition	: LREAL := 45.0; // // current position of the calibration cam. Apply an offset here if necessary
END_VAR
VAR_OUTPUT
	ready			: BOOL;		// axis is ready to operate
	error			: BOOL;		// drive error condition
	warning			: BOOL;		// warning condition
	actualPosition	: LREAL;	// actual position of the elevation axis
	errorID			: UDINT;	// error ID of the elevation axis
	calibrated		: BOOL;		// axis is calibrated
	slewTime		: LREAL;	// time to reach target position
END_VAR
VAR
	CoverControl	: I_MirrorCovers;
	fbBrake 		: I_Brake;
	comm			: I_Comm;
	
	inDigitalInputs	AT%I*	: WORD;		// digitale inputs der Endlagen
	inDiagnostic	AT%I*	: UDINT;	// diagnostic number
	inTorque		AT%I*	: INT;		// derotator torque feedback
	inSTO			AT%I*	: BOOL;		// STO
	axisRef					: AXIS_REF;	
	
	axis					: FB_Axis2;
	axisCalibration			: MC_SetPosition;
	fbSoEReset				: FB_SoEReset;
	// delay until commutator angle is measured
	readyDelay				: TON;
	// disable trigger for hydraulics
	enableTrigger			: F_TRIG;
	// store last position
	getLastPosition			: BOOL := TRUE;
	axisEvent				: FB_Eventlog;
	diagnosticEvent			: FB_Eventlog;
	brakeEvent				: FB_Eventlog;
	highElevationEvent		: FB_Eventlog;
	lowElevationEvent		: FB_Eventlog;
	torqueWarning			: FB_EventLog;
	calibrationEvent		: FB_Eventlog;
	
	torque					: REAL; 	// elevation torque in percent
	torqueTimer				: TON;		// timer to trigger a warning if torque is high
	readParameter			: MC_ReadParameter;
	diagnosticError			: BOOL;
END_VAR
VAR PERSISTENT
	lastPosition			:	LREAL := -1.0;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// limit the position input to a sane value
position := LIMIT(0.0, position, 90.0);

//if we enable the axis, we have to open the brake first
IF enable THEN
	IF NOT calibrated THEN
		CoverControl.OpenCovers();
		IF CoverControl.AreCoversOpen() THEN
			fbBrake.OpenBrake();
		END_IF
	ELSE
		fbBrake.OpenBrake();
	END_IF
	
END_IF

enableTrigger(CLK := enable);
// close the brake on the falling edge of the enable signal
IF enableTrigger.Q THEN
	fbBrake.CloseBrake();
END_IF

IF axis.Calibrated OR error THEN
	homeAxis := FALSE;
END_IF

calibrated := axis.Calibrated;

IF homeAxis THEN
	position := calibPosition;
	moveAxis := FALSE;
	tracking := FALSE;
END_IF

IF moveAxis THEN
	tracking := FALSE;
END_IF

// if NOT Enabled and ActVelo>1 then issue a warning
warning := NOT enable AND axisRef.NcToPlc.ActVelo>2.0;

// deactivate limit switches on homing
MC_SetAcceptBlockedDriveSignal(
	Axis := axisRef, 
	Enable := HomeAxis);
	
axis(
	Enable 			:= enable AND fbBrake.BrakeOpen,
	Reset 			:= reset,
	MoveAxis 		:= moveAxis,
	HomeAxis 		:= homeAxis,
	StopAxis 		:= stopAxis,
	Tracking 		:= tracking,
	Position 		:= position, 
	Velocity 		:= velocity,
	Enable_Positive := inDigitalInputs.0 OR homeAxis,
	Enable_Negative := inDigitalInputs.1,
	Jog_Forward 	:= up,
	Jog_Backwards 	:= down,
	bCalibrationCam := NOT inDigitalInputs.0,
	ActualPosition 	=> actualPosition,
	Error 			=> error,
	ErrorID 		=> errorID,
	AxisRef 		:= axisRef);

IF axis.MoveDone THEN
	moveAxis := FALSE;
END_IF

IF axis.HomeDone THEN
	homeAxis := FALSE;
END_IF
	
IF axis.ResetDone THEN
	reset := FALSE;
END_IF

IF axis.StopDone THEN
	stopAxis := FALSE;
END_IF

diagnosticError := FALSE;
IF inDiagnostic < 16#D012 AND inDiagnostic > 16#D014 THEN
	diagnosticError :=TRUE;
	errorID := inDiagnostic;
END_IF

axisCalibration(
	Axis 		:= axisRef,
	Execute 	:= getLastPosition AND lastPosition>=0.0 AND NOT calibrated,
	Position 	:= lastPosition);

IF axisCalibration.Done THEN
	getLastPosition := FALSE;
END_IF

IF calibrated THEN
	lastPosition := actualPosition;
END_IF

IF bSoEReset THEN
	lastPosition := -1.0;
	fbSoEReset(
		Axis := axisRef,
		Execute := TRUE,
		Timeout := DEFAULT_ADS_TIMEOUT);
 	IF NOT fbSoEReset.Busy THEN
		fbSoEReset(Axis := axisRef, Execute := FALSE);
		bSoEReset := FALSE;
		reset := TRUE;
	END_IF
END_IF 

readyDelay(IN :=  fbBrake.BrakeOpen, PT := T#6000MS, Q=> ready);

readParameter(	
	Axis 			:= axisRef, 
	Enable 			:= axis.InMotion, 
	ParameterNumber := MC_AxisParameter.AxisRemainingTimeToGo, 
	ReadMode 		:= E_ReadMode.READMODE_CYCLIC);
				
IF readParameter.Valid THEN
	slewTime := readParameter.Value;
END_IF

torque := inTorque / 10.0;
torqueTimer(IN := ABS(torque) > 50.0, PT := T#1000MS);
		
axisEvent(	
	Trigger 		:= error, 
	Level 			:= ADSLOG_MSGTYPE_ERROR,
	FormatString 	:= 'Elevation Axis Error: %s',
	OnMessage 		:= NCError_TO_STRING(ErrorID), 
	comm 			:= comm);

diagnosticEvent(	
	Trigger 		:= DiagnosticError,
	Level 			:= ADSLOG_MSGTYPE_ERROR,
	FormatString 	:= 'Elevation Axis Diagnostic Error: %s',
	OnMessage 		:= NCError_TO_STRING(inDiagnostic), 
	comm 			:= comm);

highElevationEvent(	
	Trigger 		:= Calibrated AND actualPosition > 85.0, 
	Level 			:= ADSLOG_MSGTYPE_WARN,
	FormatString 	:= 'High Elevation: %s',
	OnMessage 		:= LREAL_TO_FMTSTR(actualPosition, 2, TRUE), 
	comm 			:= comm);

lowElevationEvent(	
	Trigger 		:= Calibrated AND actualPosition < 5.0, 
	Level 			:= ADSLOG_MSGTYPE_WARN,
	FormatString 	:= 'Low Elevation: %s',
	OnMessage 		:= LREAL_TO_FMTSTR(actualPosition, 2, TRUE), 
	comm 			:= comm);
				
brakeEvent( 
	Trigger 		:= NOT enable AND fbBrake.BrakeOpen, 
	Level 			:= ADSLOG_MSGTYPE_WARN,
	FormatString 	:= '%s',
	OnMessage 		:= 'Brake was opened without elevation axis enabled!', 
	comm 			:= comm); 

torqueWarning(	
	Trigger 		:= torqueTimer.Q, 
	Level 			:= ADSLOG_MSGTYPE_WARN,
	FormatString 	:= '%s',
	OnMessage 		:= 'Elevation torque is high.', 
	comm 			:= comm);
	
calibrationEvent(
	Trigger 		:= Calibrated,
	Level 			:= ADSLOG_MSGTYPE_HINT,
	OnMessage 		:= 'Elevation is calibrated.', 
	comm 			:= comm);]]></ST>
    </Implementation>
    <Method Name="FB_Init" Id="{413b7b7f-fbba-45b5-beca-2a08218d35d1}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains	: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode		: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
	cover			: I_MirrorCovers;
	brake			: I_Brake;
	comm			: I_Comm;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbBrake := brake;
THIS^.CoverControl := cover;
THIS^.comm := comm;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_ElevationControl">
      <LineId Id="3435" Count="173" />
      <LineId Id="170" Count="0" />
    </LineIds>
    <LineIds Name="FB_ElevationControl.FB_Init">
      <LineId Id="1" Count="2" />
    </LineIds>
  </POU>
</TcPlcObject>